<!--Abiyaz Chowdhury, Spring 2017 ECE462 3D Dr. Mario Project-->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>3D Dr. Mario, ECE462</title>
<script type="text/javascript" src="./final_files/MV.js.download"></script>
<script type="text/javascript" src="./final_files/webgl-utils.js.download"></script>

<script id="shader-fs" type="x-shader/x-fragment">
    precision mediump float;

    varying vec4 vColor;

    void main(void) {
        gl_FragColor = vColor;
    }
</script>

<script id="shader-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    attribute vec4 aVertexColor;

    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;

    varying vec4 vColor;

    void main(void) {
        gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
        vColor = aVertexColor;
    }
</script>

<script type="text/javascript">
    //0 is red, 1 is blue, 2 is yellow
    var gl;
	var cellSize = 0.5;
	var gridweight = 0.01;
	var gridLength = 6;
	var gridWidth = 6;
	var gridDepth = 10;
	var num_virus = 10;
	var current_key = 0;
	//The grid elements will be represented by a 6 by 6 by 10 array. 
	var objectsToDraw = [];

    function initGL(canvas) {
        try {
            gl = canvas.getContext("experimental-webgl");
            gl.viewportWidth = canvas.width;
            gl.viewportHeight = canvas.height;
        } catch (e) {
        }
        if (!gl) {
            alert("Could not initialise WebGL, sorry :-(");
        }
    }

    function getShader(gl, id) {
        var shaderScript = document.getElementById(id);
        if (!shaderScript) {
            return null;
        }

        var str = "";
        var k = shaderScript.firstChild;
        while (k) {
            if (k.nodeType == 3) {
                str += k.textContent;
            }
            k = k.nextSibling;
        }

        var shader;
        if (shaderScript.type == "x-shader/x-fragment") {
            shader = gl.createShader(gl.FRAGMENT_SHADER);
        } else if (shaderScript.type == "x-shader/x-vertex") {
            shader = gl.createShader(gl.VERTEX_SHADER);
        } else {
            return null;
        }

        gl.shaderSource(shader, str);
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            alert(gl.getShaderInfoLog(shader));
            return null;
        }

        return shader;
    }

    var shaderProgram;

    function initShaders() {
        var fragmentShader = getShader(gl, "shader-fs");
        var vertexShader = getShader(gl, "shader-vs");

        shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);

        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            alert("Could not initialise shaders");
        }

        gl.useProgram(shaderProgram);

        shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
        gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);

        shaderProgram.vertexColorAttribute = gl.getAttribLocation(shaderProgram, "aVertexColor");
        gl.enableVertexAttribArray(shaderProgram.vertexColorAttribute);

        shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
        shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");
    }
	
    var mvMatrix = mat4();
    var mvMatrixStack = [];
    var pMatrix = mat4();

    function mvPushMatrix(matrix) {
        var copy = mat4();
        copy = matrix;
        mvMatrixStack.push(copy);
    }

    function mvPopMatrix() {
        if (mvMatrixStack.length == 0) {
            throw "Invalid popMatrix!";
        }
        return mvMatrixStack.pop();
    }

    function setMatrixUniforms() {
        gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, flatten(pMatrix));
        gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, flatten(mvMatrix));
    }

	var mouseDown = false;
    var lastMouseX = null;
    var lastMouseY = null;
	
    var viewRotationMatrix = mat4();
	
	function handleMouseDown(event) {
        mouseDown = true;
        lastMouseX = event.clientX;
        lastMouseY = event.clientY;
    }

    function handleMouseUp(event) {
        mouseDown = false;
    }

	var newX;
	var newY;
    function handleMouseMove(event) {
	    newX = event.clientX;
        newY = event.clientY;
        if (!mouseDown){
            return;
        }
		if ((newX > gl.viewportWidth) || (newX < 0) || (newY > gl.viewportHeight) || (newY < 0)){
			mouseDown = false;
			return;
		}
        var deltaX = newX - lastMouseX
        viewRotationMatrix = mult(rotateY(-deltaX / 2),viewRotationMatrix);
        var deltaY = newY - lastMouseY;
		viewRotationMatrix = mult(rotateX(-deltaY / 2),viewRotationMatrix);
        lastMouseX = newX
        lastMouseY = newY;
    }
	
    var xgridVertexPositionBuffer;
    var xgridVertexColorBuffer;
    var xgridVertexIndexBuffer;

	function initxgridBuffers(){
		xgridVertexPositionBuffer = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, xgridVertexPositionBuffer);
		vertices = [
            // Front face
            -3.0,  -gridweight,  gridweight,
             3.0,-gridweight,  gridweight,
            3.0,  gridweight,  gridweight,
			-3.0,  gridweight,  gridweight,

            // Back face
           -3.0,  -gridweight,  -gridweight,
             3.0, -gridweight,  -gridweight,
            3.0,  gridweight,  -gridweight,
			-3.0,  gridweight,  -gridweight,

            // Top face
            -3.0,  gridweight,  gridweight,
             -3.0, gridweight,  -gridweight,
            3.0,  gridweight,  -gridweight,
            3.0,  gridweight,  gridweight,

            // Bottom face
            -3.0,  -gridweight,  gridweight,
             -3.0, -gridweight,  -gridweight,
            3.0,  -gridweight,  -gridweight,
            3.0,  -gridweight,  gridweight,

            // Right face
             3.0,  -gridweight,  gridweight,
             3.0, -gridweight,  -gridweight,
            3.0,  gridweight,  -gridweight,
            3.0,  gridweight,  gridweight,

            // Left face
            -3.0,  -gridweight,  gridweight,
             -3.0, -gridweight,  -gridweight,
            -3.0,  gridweight,  -gridweight,
            -3.0,  gridweight,  gridweight,
        ];
		for (var i = 0; i < vertices.length; i++){
			vertices[i] *= (cellSize);
		}
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
        xgridVertexPositionBuffer.itemSize = 3;
        xgridVertexPositionBuffer.numItems = 24;
		xgridVertexColorBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, xgridVertexColorBuffer);
		
        colors = [
            [1.0, 1.0, 1.0, 1.0], // Front face
            [1.0, 1.0, 1.0, 1.0], // Back face
            [1.0, 1.0, 1.0, 1.0], // Top face
            [1.0, 1.0, 1.0, 1.0], // Bottom face
            [1.0, 1.0, 1.0, 1.0], // Right face
            [1.0, 1.0, 1.0, 1.0]  // Left face
        ];

        var unpackedColors = [];
        for (var i in colors) {
            var color = colors[i];
            for (var j=0; j < 4; j++) {
                unpackedColors = unpackedColors.concat(color);
            }
        }
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(unpackedColors), gl.STATIC_DRAW);
        xgridVertexColorBuffer.itemSize = 4;
        xgridVertexColorBuffer.numItems = 24;
		
        xgridVertexIndexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, xgridVertexIndexBuffer);
        var xgridVertexIndices = [
            0, 1, 2,      0, 2, 3,    // Front face
            4, 5, 6,      4, 6, 7,    // Back face
            8, 9, 10,     8, 10, 11,  // Top face
            12, 13, 14,   12, 14, 15, // Bottom face
            16, 17, 18,   16, 18, 19, // Right face
            20, 21, 22,   20, 22, 23  // Left face
        ];
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(xgridVertexIndices), gl.STATIC_DRAW);
        xgridVertexIndexBuffer.itemSize = 1;
        xgridVertexIndexBuffer.numItems = 36;
	}
	
	var zgridVertexPositionBuffer;
    var zgridVertexColorBuffer;
    var zgridVertexIndexBuffer;
	
	function initzgridBuffers(){
		zgridVertexPositionBuffer = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, zgridVertexPositionBuffer);
		vertices = [
            // Front face
            -gridweight,  gridweight,  3.0,
             gridweight, gridweight,  3.0,
            gridweight,  -gridweight,  3.0,
			-gridweight,  -gridweight,  3.0,

            // Back face
           -gridweight,  gridweight,  -3.0,
             gridweight, gridweight,  -3.0,
            gridweight,  -gridweight,  -3.0,
			-gridweight,  -gridweight,  -3.0,

            // Top face
            -gridweight,  gridweight,  3.0,
             -gridweight, gridweight,  -3.0,
            gridweight,  gridweight,  -3.0,
            gridweight,  gridweight,  3.0,

            // Bottom face
            -gridweight,  -gridweight,  3.0,
             -gridweight, -gridweight,  -3.0,
            gridweight,  -gridweight,  -3.0,
            gridweight,  -gridweight,  3.0,

            // Right face
             gridweight,  -gridweight,  3.0,
             gridweight, -gridweight,  -3.0,
            gridweight,  gridweight,  -3.0,
            gridweight,  gridweight,  3.0,

            // Left face
            -gridweight,  -gridweight,  3.0,
             -gridweight, -gridweight,  -3.0,
            -gridweight,  gridweight,  -3.0,
            -gridweight,  gridweight,  3.0,
        ];
		for (var i = 0; i < vertices.length; i++){
			vertices[i] *= (cellSize);
		}
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
        zgridVertexPositionBuffer.itemSize = 3;
        zgridVertexPositionBuffer.numItems = 24;
		zgridVertexColorBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, zgridVertexColorBuffer);
		
        colors = [
            [1.0, 1.0, 1.0, 1.0], // Front face
            [1.0, 1.0, 1.0, 1.0], // Back face
            [1.0, 1.0, 1.0, 1.0], // Top face
            [1.0, 1.0, 1.0, 1.0], // Bottom face
            [1.0, 1.0, 1.0, 1.0], // Right face
            [1.0, 1.0, 1.0, 1.0]  // Left face
        ];

        var unpackedColors = [];
        for (var i in colors) {
            var color = colors[i];
            for (var j=0; j < 4; j++) {
                unpackedColors = unpackedColors.concat(color);
            }
        }
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(unpackedColors), gl.STATIC_DRAW);
        zgridVertexColorBuffer.itemSize = 4;
        zgridVertexColorBuffer.numItems = 24;
		
        zgridVertexIndexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, zgridVertexIndexBuffer);
        var zgridVertexIndices = [
            0, 1, 2,      0, 2, 3,    // Front face
            4, 5, 6,      4, 6, 7,    // Back face
            8, 9, 10,     8, 10, 11,  // Top face
            12, 13, 14,   12, 14, 15, // Bottom face
            16, 17, 18,   16, 18, 19, // Right face
            20, 21, 22,   20, 22, 23  // Left face
        ];
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(zgridVertexIndices), gl.STATIC_DRAW);
        zgridVertexIndexBuffer.itemSize = 1;
        zgridVertexIndexBuffer.numItems = 36;
	}
	
	var ygridVertexPositionBuffer;
    var ygridVertexColorBuffer;
    var ygridVertexIndexBuffer;
	
	function initygridBuffers(){
		ygridVertexPositionBuffer = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, ygridVertexPositionBuffer);
		vertices = [
            // Front face
            -gridweight,  -5.0,  gridweight,
             gridweight,-5.0,  gridweight,
            gridweight,  5.0,  gridweight,
			-gridweight,  5.0,  gridweight,

            // Back face
           -gridweight,  -5.0,  -gridweight,
             gridweight,-5.0,  -gridweight,
            gridweight,  5.0,  -gridweight,
			-gridweight,  5.0,  -gridweight,

            // Top face
            -gridweight,  5.0,  gridweight,
             -gridweight, 5.0,  -gridweight,
            gridweight,  5.0,  -gridweight,
            gridweight,  5.0,  gridweight,

            // Bottom face
            -gridweight,  -5.0,  gridweight,
             -gridweight, -5.0,  -gridweight,
            gridweight,  -5.0,  -gridweight,
            gridweight,  -5.0,  gridweight,

            // Right face
             gridweight,  -5.0,  gridweight,
             gridweight, -5.0,  -gridweight,
            gridweight,  5.0,  -gridweight,
            gridweight,  5.0,  gridweight,

            // Left face
            -gridweight,  -5.0,  gridweight,
             -gridweight, -5.0,  -gridweight,
            -gridweight,  5.0,  -gridweight,
            -gridweight,  5.0,  gridweight,
        ];
		for (var i = 0; i < vertices.length; i++){
			vertices[i] *= (cellSize);
		}
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
        ygridVertexPositionBuffer.itemSize = 3;
        ygridVertexPositionBuffer.numItems = 24;
		ygridVertexColorBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, ygridVertexColorBuffer);
		
        colors = [
            [1.0, 1.0, 1.0, 1.0], // Front face
            [1.0, 1.0, 1.0, 1.0], // Back face
            [1.0, 1.0, 1.0, 1.0], // Top face
            [1.0, 1.0, 1.0, 1.0], // Bottom face
            [1.0, 1.0, 1.0, 1.0], // Right face
            [1.0, 1.0, 1.0, 1.0]  // Left face
        ];

        var unpackedColors = [];
        for (var i in colors) {
            var color = colors[i];
            for (var j=0; j < 4; j++) {
                unpackedColors = unpackedColors.concat(color);
            }
        }
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(unpackedColors), gl.STATIC_DRAW);
        ygridVertexColorBuffer.itemSize = 4;
        ygridVertexColorBuffer.numItems = 24;
		
        ygridVertexIndexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ygridVertexIndexBuffer);
        var ygridVertexIndices = [
            0, 1, 2,      0, 2, 3,    // Front face
            4, 5, 6,      4, 6, 7,    // Back face
            8, 9, 10,     8, 10, 11,  // Top face
            12, 13, 14,   12, 14, 15, // Bottom face
            16, 17, 18,   16, 18, 19, // Right face
            20, 21, 22,   20, 22, 23  // Left face
        ];
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(ygridVertexIndices), gl.STATIC_DRAW);
        ygridVertexIndexBuffer.itemSize = 1;
        ygridVertexIndexBuffer.numItems = 36;
	}
	
    function drawScene() {
        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        pMatrix = perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0);
		mvMatrix = mat4();
		drawGrid();
		drawGridObjects();
    }
	
	function drawGridObjects(){
			for (key in objectsToDraw){
			mvPushMatrix(mvMatrix);
			mvMatrix = mult(translate(objectsToDraw[key].center),mvMatrix);
			mvMatrix = mult(viewRotationMatrix,mvMatrix);
			mvMatrix = mult(translate(0,0.0,-8.0),mvMatrix);
			gl.bindBuffer(gl.ARRAY_BUFFER, objectsToDraw[key].position_buffer);
			gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, objectsToDraw[key].position_buffer.itemSize, gl.FLOAT, false, 0, 0);
			gl.bindBuffer(gl.ARRAY_BUFFER, objectsToDraw[key].color_buffer);
			gl.vertexAttribPointer(shaderProgram.vertexColorAttribute, objectsToDraw[key].color_buffer.itemSize, gl.FLOAT, false, 0, 0);
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, objectsToDraw[key].index_buffer);
			setMatrixUniforms();
			gl.drawElements(gl.TRIANGLES, objectsToDraw[key].index_buffer.numItems, gl.UNSIGNED_SHORT, 0);
			mvMatrix = mvPopMatrix();
		}
	}
		
	function drawGrid(){
	for (var i = 0; i < 11 ; i++){
			for (var j = 0; j < 7; j++){
					mvPushMatrix(mvMatrix);
					var instance_transformation = mat4();
					instance_transformation = mult(translate(0,(i-5)*cellSize,(j-3)*cellSize),instance_transformation);
					mvMatrix = mult(instance_transformation,mvMatrix);
					mvMatrix = mult(viewRotationMatrix,mvMatrix);
					mvMatrix = mult(translate(0.0,0.0,-8.0),mvMatrix);
					gl.bindBuffer(gl.ARRAY_BUFFER, xgridVertexPositionBuffer);
					gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, xgridVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
					gl.bindBuffer(gl.ARRAY_BUFFER, xgridVertexColorBuffer);
					gl.vertexAttribPointer(shaderProgram.vertexColorAttribute, xgridVertexColorBuffer.itemSize, gl.FLOAT, false, 0, 0);
					gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, xgridVertexIndexBuffer);
					setMatrixUniforms();
					gl.drawElements(gl.TRIANGLES, xgridVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
					mvMatrix = mvPopMatrix();
			}
		}
		for (var i = 0; i < 11 ; i++){
			for (var j = 0; j < 7; j++){
					mvPushMatrix(mvMatrix);
					var instance_transformation = mat4();
					instance_transformation = mult(translate((j-3)*cellSize,(i-5)*cellSize,0),instance_transformation);
					mvMatrix = mult(instance_transformation,mvMatrix);
					mvMatrix = mult(viewRotationMatrix,mvMatrix);
					mvMatrix = mult(translate(0.0,0.0,-8.0),mvMatrix);
					gl.bindBuffer(gl.ARRAY_BUFFER, zgridVertexPositionBuffer);
					gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, zgridVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
					gl.bindBuffer(gl.ARRAY_BUFFER, zgridVertexColorBuffer);
					gl.vertexAttribPointer(shaderProgram.vertexColorAttribute, zgridVertexColorBuffer.itemSize, gl.FLOAT, false, 0, 0);
					gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, zgridVertexIndexBuffer);
					setMatrixUniforms();
					gl.drawElements(gl.TRIANGLES, zgridVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
					mvMatrix = mvPopMatrix();
			}
		}
		for (var i = 0; i < 7 ; i++){
			for (var j = 0; j < 7; j++){
					mvPushMatrix(mvMatrix);
					var instance_transformation = mat4();
					instance_transformation = mult(translate((j-3)*cellSize,0,(i-3)*cellSize),instance_transformation);
					mvMatrix = mult(instance_transformation,mvMatrix);
					mvMatrix = mult(viewRotationMatrix,mvMatrix);
					mvMatrix = mult(translate(0.0,0.0,-8.0),mvMatrix);
					gl.bindBuffer(gl.ARRAY_BUFFER, ygridVertexPositionBuffer);
					gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, ygridVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
					gl.bindBuffer(gl.ARRAY_BUFFER, ygridVertexColorBuffer);
					gl.vertexAttribPointer(shaderProgram.vertexColorAttribute, ygridVertexColorBuffer.itemSize, gl.FLOAT, false, 0, 0);
					gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ygridVertexIndexBuffer);
					setMatrixUniforms();
					gl.drawElements(gl.TRIANGLES, ygridVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
					mvMatrix = mvPopMatrix();
			}
		}
	}
	
	var state = 0; //if state  is 0, then pill should move down slowly. 
	//if state is 1, then this is grace period, which lasts for 1 second, and lets you rotate or move sideways (if allowed). if state is 2, then we flash for 1 second.
	
	function tick() {
        requestAnimFrame(tick);
        drawScene();
		if ((state == 0)||(state == 1)||(state == 2)){
			time_step();
		}
    }
	
	var lastTime = 0;
	var elapsed = 0;
	
	function time_step(){
		var timeNow = new Date().getTime();
		if (lastTime != 0){
			elapsed += (timeNow - lastTime);
			lastTime = timeNow;
		}else{
			lastTime = timeNow;
		}
		if (state == 2){
			var frac = (elapsed)/1000;
			switch(matching_data[0]){
				case 0:
					for (var i = 0; i < matching_data[4]; i++){
						var target_color = brighten(convert_color_code(grid[matching_data[1]+i][matching_data[2]][matching_data[3]].color),frac);
						var cell_to_delete =  grid[matching_data[1]+i][matching_data[2]][matching_data[3]].code;
						grid[matching_data[1]+i][matching_data[2]][matching_data[3]].code = current_key;
						if (grid[matching_data[1]+i][matching_data[2]][matching_data[3]].state == 1){
						  //virus
						  create_sphere(cell_to_display(matching_data[1]+i,matching_data[2],matching_data[3]),target_color);
						}else{
						  //solid
						  create_cube(cell_to_display(matching_data[1]+i,matching_data[2],matching_data[3]),target_color);
						}
						 delete objectsToDraw[cell_to_delete];
					}
					break;
				case 1:
					for (var i = 0; i < matching_data[4]; i++){
						var target_color = brighten(convert_color_code(grid[matching_data[1]][matching_data[2]+i][matching_data[3]].color),frac);
						var cell_to_delete =  grid[matching_data[1]][matching_data[2]+i][matching_data[3]].code;
						grid[matching_data[1]][matching_data[2]+i][matching_data[3]].code = current_key;
						if (grid[matching_data[1]][matching_data[2]+i][matching_data[3]].state == 1){
						  //virus
						  create_sphere(cell_to_display(matching_data[1],matching_data[2]+i,matching_data[3]),target_color);
						}else{
						  //solid
						  create_cube(cell_to_display(matching_data[1],matching_data[2]+i,matching_data[3]),target_color);
						}
						 delete objectsToDraw[cell_to_delete];
					}
					break;
				case 2:
					for (var i = 0; i < matching_data[4]; i++){
						var target_color = brighten(convert_color_code(grid[matching_data[1]][matching_data[2]][matching_data[3]+i].color),frac);
						var cell_to_delete =  grid[matching_data[1]][matching_data[2]][matching_data[3]+i].code;
						grid[matching_data[1]][matching_data[2]][matching_data[3]+i].code = current_key;
						if (grid[matching_data[1]][matching_data[2]][matching_data[3]+i].state == 1){
						  //virus
						  create_sphere(cell_to_display(matching_data[1],matching_data[2],matching_data[3]+i),target_color);
						}else{
						  //solid
						  create_cube(cell_to_display(matching_data[1],matching_data[2],matching_data[3]+i),target_color);
						}
						 delete objectsToDraw[cell_to_delete];
					}
					break;
				default:
					break;
			}
		}
		if (elapsed > 1000){
			lastTime = 0;
			elapsed = 0;
			if (state == 0){
				current_cells[0][2] -= 1;
				current_cells[1][2] -= 1;
				objectsToDraw[current_code[0]].center[1] -= cellSize ;
				objectsToDraw[current_code[1]].center[1] -= cellSize ;
				if (down_collision()){
					state = 1;
				}
			}else if (state == 1){
				state = 0;
				if ((current_cells[0].toString() == [3,2,9])||(current_cells[0].toString() == [3,3,9])||(current_cells[1].toString() == [3,2,9])||(current_cells[1].toString() == [3,3,9])){
						state = 3;
						document.getElementById("gamestatus").innerHTML = "GAME OVER.";
				}else{
					register_current();
					if (state != 2){
						if (down_collision()){
							console.log("ok");
							state = 1;
						};
					}
				}
			}else if (state == 2){
				switch(matching_data[0]){
				case 0:
					for (var i = 0; i < matching_data[4]; i++){
						var cell_to_delete =  grid[matching_data[1]+i][matching_data[2]][matching_data[3]].code;
						if (grid[matching_data[1]+i][matching_data[2]][matching_data[3]].state == 1){
							num_virus--;
							document.getElementById("gamestatus").innerHTML = "Game in progress. Viruses left: " + num_virus;
						}
						delete objectsToDraw[cell_to_delete];
						grid[matching_data[1]+i][matching_data[2]][matching_data[3]].state = 0;
						grid[matching_data[1]+i][matching_data[2]][matching_data[3]].color = -1;
						grid[matching_data[1]+i][matching_data[2]][matching_data[3]].code = 0;
					}
					break;
				case 1:
					for (var i = 0; i < matching_data[4]; i++){
						var cell_to_delete =  grid[matching_data[1]][matching_data[2]+i][matching_data[3]].code;
						if (grid[matching_data[1]][matching_data[2]+i][matching_data[3]].state == 1){
							num_virus--;
							document.getElementById("gamestatus").innerHTML = "Game in progress. Viruses left: " + num_virus;
						}
						delete objectsToDraw[cell_to_delete];
						grid[matching_data[1]][matching_data[2]+i][matching_data[3]].state = 0;
						grid[matching_data[1]][matching_data[2]+i][matching_data[3]].color = -1;
						grid[matching_data[1]][matching_data[2]+i][matching_data[3]].code = 0;
					}
					break;
				case 2:
					for (var i = 0; i < matching_data[4]; i++){
						var cell_to_delete =  grid[matching_data[1]][matching_data[2]][matching_data[3]+i].code;
						if (grid[matching_data[1]][matching_data[2]][matching_data[3]+i].state == 1){
							num_virus--;
							document.getElementById("gamestatus").innerHTML = "Game in progress. Viruses left: " + num_virus;
						}
						delete objectsToDraw[cell_to_delete];
						grid[matching_data[1]][matching_data[2]][matching_data[3]+i].state = 0;
						grid[matching_data[1]][matching_data[2]][matching_data[3]+i].color = -1;
						grid[matching_data[1]][matching_data[2]][matching_data[3]+i].code = 0;
					}
					break;
				default:
					break;
				}
				matching_data = testMatch();
				if (num_virus == 0){
					state = 3;
					document.getElementById("gamestatus").innerHTML = "YOU WIN. NICE JOB.";
				}else if (matching_data[0] < 0){
					state = 0;
					initialize_current();
				}
			}
		}
	}
	
	function down_collision(){
		//test for down collision with other cells here
		//test for down collision with grid floor here
		var min_y = Math.min(current_cells[0][2],current_cells[1][2]);
		if (min_y == 0){
			return true;
		}
		for (var i = 0; i < 2; i++){
			if (grid[current_cells[i][0]][current_cells[i][1]][current_cells[i][2]-1].state != 0){
				return true;
			}
		}
		return false;
	}
	
	function left_collision(){
		var min_x = Math.min(current_cells[0][0],current_cells[1][0]);
		if (min_x == 0){
			return true;
		}
		for (var i = 0; i < 2; i++){
			if (grid[current_cells[i][0]-1][current_cells[i][1]][current_cells[i][2]].state != 0){
				return true;
			}
		}
		return false;
	}
	
	function right_collision(){
		var max_x = Math.max(current_cells[0][0],current_cells[1][0]);
		if (max_x == gridLength-1){
			return true;
		}
		for (var i = 0; i < 2; i++){
			if (grid[current_cells[i][0]+1][current_cells[i][1]][current_cells[i][2]].state != 0){
				return true;
			}
		}
		return false;
	}
	
	function away_collision(){
		var max_z = Math.max(current_cells[0][1],current_cells[1][1]);
		if (max_z == gridWidth-1){
			return true;
		}
		for (var i = 0; i < 2; i++){
			if (grid[current_cells[i][0]][current_cells[i][1]+1][current_cells[i][2]].state != 0){
				return true;
			}
		}
		return false;
	}
	
	function toward_collision(){
		var min_z = Math.min(current_cells[0][1],current_cells[1][1]);
		if (min_z == 0){
			return true;
		}
		for (var i = 0; i < 2; i++){
			if (grid[current_cells[i][0]][current_cells[i][1]-1][current_cells[i][2]].state != 0){
				return true;
			}
		}
		return false;
	}

	var matching_data = [];
	
	function register_current(){
		var first = current_cells[0]
		var second = current_cells[1]
		//update grid and also update draw array to display the newly registered cells
		grid[first[0]][first[1]][first[2]].state = 2;
		grid[first[0]][first[1]][first[2]].color = current_color[0];
		grid[first[0]][first[1]][first[2]].code = current_key;
		create_cube(cell_to_display(first[0],first[1],first[2]),convert_color_code(current_color[0]));
		grid[second[0]][second[1]][second[2]].state = 2;
		grid[second[0]][second[1]][second[2]].color = current_color[1];
		grid[second[0]][second[1]][second[2]].code = current_key;
		create_cube(cell_to_display(second[0],second[1],second[2]),convert_color_code(current_color[1]))
		//delete the existing current pill in the draw array
		delete objectsToDraw[current_code[0]];
		delete objectsToDraw[current_code[1]];
		matching_data = testMatch();
		if (matching_data[0] > -1){
			console.log("entering match state");
			state = 2;
		}else{
			initialize_current();
		}
		//create a new current pill
	}
	
	var grid = new Array();
	//grid.state 0 for empty, 1 for virus, 2 for solid
	//0 for red, 1 for blue, 2 for yellow
	//the first index is left to right of grid, second index is front to back, third index is bottom to top;

	function create_virus(){
		for (var i = 0; i < num_virus; i++){
			var germ_x = Math.floor((Math.random() * gridLength));
			var germ_y = Math.floor((Math.random() * (gridDepth/2)));
			var germ_z = Math.floor((Math.random() * gridWidth));
			var germ_color = Math.floor((Math.random() * 3))
			if (grid[germ_x][germ_z][germ_y].state == 0){
				grid[germ_x][germ_z][germ_y].state = 1;
				grid[germ_x][germ_z][germ_y].color = germ_color;
				grid[germ_x][germ_z][germ_y].code = current_key;
				create_sphere(cell_to_display(germ_x,germ_z,germ_y),convert_color_code(germ_color));
			}else{
				i--;
			}
		}
		document.getElementById("gamestatus").innerHTML = "Game in progress. Viruses left: " + num_virus;
	}

	function initialize_grid_array(){
		for (var i = 0; i < gridLength; i++){
			grid[i] = new Array();
			for (var j = 0; j < gridWidth; j++){
				grid[i][j] = new Array();
				for (var k = 0; k < gridDepth; k++){
					grid[i][j][k] = {
						state: 0, //0 for empty, 1 for virus, 2 for solid
						color: -1, //0 for red, 1 for blue, 2 for yellow
						code: -1
					};
				}
			}
		}
	}
	
	function cell_to_display(x,z,y){
		//inputs 0,0,0 represent the bottom left front of the cube.
		 return [(cellSize/2)*(2*x-5),(cellSize/2)*(-9+2*y),(cellSize/2)*(5-2*z)];
	}
	
	function convert_color_code(s){
		switch (s){
			case 0: //magenta
				return [1.0,0.0,0.7,1.0];
			case 1: //cyan
				return [0.0,0.7,0.7,1.0];
			case 2: //yellow
				return [1.0,1.0,0.0,1.0];
			default:
				break;
		}
	}
	
    function webGLStart() {
        var canvas = document.getElementById("lesson04-canvas");
        initGL(canvas);
        initShaders()
		initxgridBuffers() //setup instance transformation matrices of every cube and buffers
		initzgridBuffers()
		initygridBuffers()
		//create_cube([5*cellSize/2,9*cellSize/2,-5*cellSize/2],[1.0,0.0,0.0,1.0]);
		//create_octahedron([0.0,0.0,0.0],[0.0,0.0,0.0,1.0])
		//create_sphere([-cellSize/2,-cellSize/2,-cellSize/2],[1.0,1.0,0.0,1.0]);
		initialize_grid_array();
		create_xaxis();
		create_zaxis();
		create_yaxis();
		create_virus();
		initialize_current();
        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.enable(gl.DEPTH_TEST);
		document.onmousedown = handleMouseDown;
        document.onmouseup = handleMouseUp;
        document.onmousemove = handleMouseMove;
		document.onkeydown = function(event) {
			handlekeypress(event.keyCode);
		}
		tick();
    }
	
	function handlekeypress(key){
		if (state > 1){
			return;
		}
		switch(key){
			case 37: //left (-x)
				if (!left_collision()){
					current_cells[0][0] -= 1;
					current_cells[1][0] -= 1;
					objectsToDraw[current_code[0]].center[0] -= cellSize ;
					objectsToDraw[current_code[1]].center[0] -= cellSize ;
					if (state == 0){
						if (down_collision()){
							state = 1;
							elapsed = 0;
							lastTime = 0;
						}
					}else if (state  == 1){
						if (down_collision()){
							state = 1;
						}else{
							state = 0;
						}
					}
				}
				break;
			case 38: //away from viewer (-z axis)
				if (!away_collision()){
					current_cells[0][1] += 1;
					current_cells[1][1] += 1;
					objectsToDraw[current_code[0]].center[2] -= cellSize ;
					objectsToDraw[current_code[1]].center[2] -= cellSize ;
					if (state == 0){
						if (down_collision()){
							state = 1;
							elapsed = 0;
							lastTime = 0;
						}
					}else if (state  == 1){
						if (down_collision()){
							state = 1;
						}else{
							state = 0;
						}
					}
				}
				break;
			case 39: //right (+x)
				if (!right_collision()){
					current_cells[0][0] += 1;
					current_cells[1][0] += 1;
					objectsToDraw[current_code[0]].center[0] += cellSize ;
					objectsToDraw[current_code[1]].center[0] += cellSize ;
					if (state == 0){
						if (down_collision()){
							state = 1;
							elapsed = 0;
							lastTime = 0;
						}
					}else if (state  == 1){
						if (down_collision()){
							state = 1;
						}else{
							state = 0;
						}
					}
				}
				break;
			case 40: //toward viewer (+z axis)
				if (!toward_collision()){
					current_cells[0][1] -= 1;
					current_cells[1][1] -= 1;
					objectsToDraw[current_code[0]].center[2] += cellSize ;
					objectsToDraw[current_code[1]].center[2] += cellSize ;
					if (state == 0){
						if (down_collision()){
							state = 1;
							elapsed = 0;
							lastTime = 0;
						}
					}else if (state  == 1){
						if (down_collision()){
							state = 1;
						}else{
							state = 0;
						}
					}
				}
				break;
			case 65: //a  rotate counterclockwise around right axis
				if (current_cells[0][0] == current_cells[1][0]){
					var offset = [current_cells[1][1]-current_cells[0][1],current_cells[1][2]-current_cells[0][2]];
					var destination = counterclockwise(offset);
					//console.log("destination offset:" + destination);
					destination[0] += current_cells[0][1];
					destination[1] += current_cells[0][2];
					//console.log("destination :" + destination);
					var pass_through = counterclockwise_pass(offset);
					pass_through[0] += current_cells[0][1];
					pass_through[1] += current_cells[0][2];
					if ((destination[0]>-1)&&(destination[1]>-1)&&(destination[0]<gridWidth)&&(destination[1]<gridDepth)){
						if (grid[current_cells[0][0]][destination[0]][destination[1]].state == 0){
							if (grid[current_cells[0][0]][pass_through[0]][pass_through[1]].state == 0){
									current_cells[1][1] = destination[0];
									current_cells[1][2] = destination[1];
									var coordinates = cell_to_display(current_cells[0][0],destination[0],destination[1]);
									objectsToDraw[current_code[1]].center = coordinates;
							}
						}
					}
					if (state == 0){
						if (down_collision()){
							state = 1;
							elapsed = 0;
							lastTime = 0;
						}
					}else if (state  == 1){
						if (down_collision()){
							state = 1;
						}else{
							state = 0;
						}
					}
				}
				break;
			case 83: //s rootate counterclockwise around away-axis
				if (current_cells[0][1] == current_cells[1][1]){
					var offset = [current_cells[1][0]-current_cells[0][0],current_cells[1][2]-current_cells[0][2]];
					var destination = counterclockwise(offset);
					destination[0] += current_cells[0][0];
					destination[1] += current_cells[0][2];
					var pass_through = counterclockwise_pass(offset);
					pass_through[0] += current_cells[0][0];
					pass_through[1] += current_cells[0][2];
					if ((destination[0]>-1)&&(destination[1]>-1)&&(destination[0]<gridLength)&&(destination[1]<gridDepth)){
						if (grid[destination[0]][current_cells[0][1]][destination[1]].state == 0){
							if (grid[pass_through[0]][current_cells[0][1]][pass_through[1]].state == 0){
									current_cells[1][0] = destination[0];
									current_cells[1][2] = destination[1];
									var coordinates = cell_to_display(destination[0],current_cells[0][1],destination[1]);
									objectsToDraw[current_code[1]].center = coordinates;
							}
						}
					}
					if (state == 0){
						if (down_collision()){
							state = 1;
							elapsed = 0;
							lastTime = 0;
						}
					}else if (state  == 1){
						if (down_collision()){
							state = 1;
						}else{
							state = 0;
						}
					}
				}
				break;
			case 68: //d rotate counterclockwise around up-axis
				if (current_cells[0][2] == current_cells[1][2]){
					var offset = [current_cells[1][0]-current_cells[0][0],current_cells[1][1]-current_cells[0][1]];
					var destination = counterclockwise(offset);
					destination[0] += current_cells[0][0];
					destination[1] += current_cells[0][1];
					var pass_through = counterclockwise_pass(offset);
					pass_through[0] += current_cells[0][0];
					pass_through[1] += current_cells[0][1];
					if ((destination[0]>-1)&&(destination[1]>-1)&&(destination[0]<gridLength)&&(destination[1]<gridWidth)){
						if (grid[destination[0]][destination[1]][current_cells[0][2]].state == 0){
							if (grid[pass_through[0]][current_cells[0][1]][pass_through[1]].state == 0){
									current_cells[1][0] = destination[0];
									current_cells[1][1] = destination[1];
									var coordinates = cell_to_display(destination[0],destination[1],current_cells[0][2]);
									objectsToDraw[current_code[1]].center = coordinates;
							}
						}
					}
					if (state == 0){
						if (down_collision()){
							state = 1;
							elapsed = 0;
							lastTime = 0;
						}
					}else if (state  == 1){
						if (down_collision()){
							state = 1;
						}else{
							state = 0;
						}
					}
				}
				break;
			case 90: //z  rotate clockwise around right axis
				if (current_cells[0][0] == current_cells[1][0]){
					var offset = [current_cells[1][1]-current_cells[0][1],current_cells[1][2]-current_cells[0][2]];
					var destination = clockwise(offset);
					//console.log("destination offset:" + destination);
					destination[0] += current_cells[0][1];
					destination[1] += current_cells[0][2];
					//console.log("destination :" + destination);
					var pass_through = clockwise_pass(offset);
					pass_through[0] += current_cells[0][1];
					pass_through[1] += current_cells[0][2];
					if ((destination[0]>-1)&&(destination[1]>-1)&&(destination[0]<gridWidth)&&(destination[1]<gridDepth)){
						if (grid[current_cells[0][0]][destination[0]][destination[1]].state == 0){
							if (grid[current_cells[0][0]][pass_through[0]][pass_through[1]].state == 0){
									current_cells[1][1] = destination[0];
									current_cells[1][2] = destination[1];
									var coordinates = cell_to_display(current_cells[0][0],destination[0],destination[1]);
									objectsToDraw[current_code[1]].center = coordinates;
							}
						}
					}
					if (state == 0){
						if (down_collision()){
							state = 1;
							elapsed = 0;
							lastTime = 0;
						}
					}else if (state  == 1){
						if (down_collision()){
							state = 1;
						}else{
							state = 0;
						}
					}
				}
				break;
			case 88: //x rootate clockwise around away-axis
				if (current_cells[0][1] == current_cells[1][1]){
					var offset = [current_cells[1][0]-current_cells[0][0],current_cells[1][2]-current_cells[0][2]];
					var destination = clockwise(offset);
					destination[0] += current_cells[0][0];
					destination[1] += current_cells[0][2];
					var pass_through = clockwise_pass(offset);
					pass_through[0] += current_cells[0][0];
					pass_through[1] += current_cells[0][2];
					if ((destination[0]>-1)&&(destination[1]>-1)&&(destination[0]<gridLength)&&(destination[1]<gridDepth)){
						if (grid[destination[0]][current_cells[0][1]][destination[1]].state == 0){
							if (grid[pass_through[0]][current_cells[0][1]][pass_through[1]].state == 0){
									current_cells[1][0] = destination[0];
									current_cells[1][2] = destination[1];
									var coordinates = cell_to_display(destination[0],current_cells[0][1],destination[1]);
									objectsToDraw[current_code[1]].center = coordinates;
							}
						}
					}
					if (state == 0){
						if (down_collision()){
							state = 1;
							elapsed = 0;
							lastTime = 0;
						}
					}else if (state  == 1){
						if (down_collision()){
							state = 1;
						}else{
							state = 0;
						}
					}
				}
				break;
			case 67: //c rotate clockwise around up-axis
				if (current_cells[0][2] == current_cells[1][2]){
					var offset = [current_cells[1][0]-current_cells[0][0],current_cells[1][1]-current_cells[0][1]];
					var destination = clockwise(offset);
					destination[0] += current_cells[0][0];
					destination[1] += current_cells[0][1];
					var pass_through = clockwise_pass(offset);
					pass_through[0] += current_cells[0][0];
					pass_through[1] += current_cells[0][1];
					if ((destination[0]>-1)&&(destination[1]>-1)&&(destination[0]<gridLength)&&(destination[1]<gridWidth)){
						if (grid[destination[0]][destination[1]][current_cells[0][2]].state == 0){
							if (grid[pass_through[0]][current_cells[0][1]][pass_through[1]].state == 0){
									current_cells[1][0] = destination[0];
									current_cells[1][1] = destination[1];
									var coordinates = cell_to_display(destination[0],destination[1],current_cells[0][2]);
									objectsToDraw[current_code[1]].center = coordinates;
							}
						}
					}
					if (state == 0){
						if (down_collision()){
							state = 1;
							elapsed = 0;
							lastTime = 0;
						}
					}else if (state  == 1){
						if (down_collision()){
							state = 1;
						}else{
							state = 0;
						}
					}
				}
				break;
			default:
				break;
		}
	}
	
	function counterclockwise(vec){
		return [-vec[1],vec[0]];
	}
	
	function clockwise(vec){
		return [vec[1],-vec[0]];
	}
	
	function testMatch(){
		//x-axis test
		for (var i = 0; i < gridLength-2; i++){
			for (var j = 0; j < gridWidth; j++){
				for (var k = 0; k < gridDepth; k++){
					if (grid[i][j][k].state != 0){
						var match = 1;
						while ((i+match<gridLength)&&(grid[i+match][j][k].state != 0)&&(grid[i][j][k].color == grid[i+match][j][k].color)){
							match++;
						}
						if (match>2){
							return [0,i,j,k,match];
						}
					}
				}
			}	
		}
		//z-axis 
		for (var i = 0; i < gridLength; i++){
			for (var j = 0; j < gridWidth-2; j++){
				for (var k = 0; k < gridDepth; k++){
					if (grid[i][j][k].state != 0){
						var match = 1;
						while ((j+match<gridWidth)&&(grid[i][j+match][k].state != 0)&&(grid[i][j+match][k].color == grid[i][j][k].color)){
							match++;
						}
						if (match>2){
							return [1,i,j,k,match];
						}
					}
				}
			}	
		}
		//y-axis
		for (var i = 0; i < gridLength; i++){
			for (var j = 0; j < gridWidth; j++){
				for (var k = 0; k < gridDepth-2; k++){
					if (grid[i][j][k].state != 0){
						var match = 1;
						while ((k+match<gridDepth)&&(grid[i][j][k+match].state != 0)&&(grid[i][j][k+match].color == grid[i][j][k].color)){
							match++;
						}
						if (match>2){
							return [2,i,j,k,match];
						}
					}
				}
			}	
		}
		return [-1,0,0,0,0];
	}
	
	function counterclockwise_pass(vec){
		return [vec[0]-vec[1],vec[0]+vec[1]];
	}
	
	function clockwise_pass(vec){
		return [vec[0]+vec[1],vec[1]-vec[0]];
	}
	
	var current_cells = [];
	var current_color = [];
	var current_code = [];
	
	function initialize_current(){
		current_cells[0] = [3,2,9];
		current_cells[1] = [3,3,9];
		current_color[0] = Math.floor((Math.random() * 3));
		current_color[1] = Math.floor((Math.random() * 3));
		current_code[0] = current_key;
		create_cube(cell_to_display(current_cells[0][0],current_cells[0][1],current_cells[0][2]),brighten(convert_color_code(current_color[0]),0.3));
		current_code[1] = current_key;
		create_cube(cell_to_display(current_cells[1][0],current_cells[1][1],current_cells[1][2]),brighten(convert_color_code(current_color[1]),0.3));
	}
	
	function brighten(color, factor){
		var temp  = color;
		for (var i = 0; i < 3; i++){
			temp[i] += (1-temp[i])*factor;
		}
		temp[3] = color[3];
		return temp;
	}
	
	function create_cube(center_coordinates,color){
		var VertexPositionBuffer = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, VertexPositionBuffer);
		vertices = [// Front face
            -1.0, -1.0,  1.0,
             1.0, -1.0,  1.0,
             1.0,  1.0,  1.0,
            -1.0,  1.0,  1.0,

            // Back face
            -1.0, -1.0, -1.0,
            -1.0,  1.0, -1.0,
             1.0,  1.0, -1.0,
             1.0, -1.0, -1.0,

            // Top face
            -1.0,  1.0, -1.0,
            -1.0,  1.0,  1.0,
             1.0,  1.0,  1.0,
             1.0,  1.0, -1.0,

            // Bottom face
            -1.0, -1.0, -1.0,
             1.0, -1.0, -1.0,
             1.0, -1.0,  1.0,
            -1.0, -1.0,  1.0,

            // Right face
             1.0, -1.0, -1.0,
             1.0,  1.0, -1.0,
             1.0,  1.0,  1.0,
             1.0, -1.0,  1.0,

            // Left face
            -1.0, -1.0, -1.0,
            -1.0, -1.0,  1.0,
            -1.0,  1.0,  1.0,
            -1.0,  1.0, -1.0
        ];
		for (var i = 0; i < vertices.length; i++){
			vertices[i] *= .49*cellSize;
		}
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
        VertexPositionBuffer.itemSize = 3;
        VertexPositionBuffer.numItems = 24;
		var VertexColorBuffer = gl.createBuffer()
		gl.bindBuffer(gl.ARRAY_BUFFER, VertexColorBuffer);
		var unpackedColors = [];
		for (var k = 0; k < 24; k++){ //24 because the vertex buffer has 24 vertices, each must have a color
				unpackedColors = unpackedColors.concat(color);
		}
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(unpackedColors), gl.STATIC_DRAW);
		VertexColorBuffer.itemSize = 4;
		VertexColorBuffer.numItems = 24;
		
        var VertexIndexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, VertexIndexBuffer);
        var VertexIndices = [
            0, 1, 2,      0, 2, 3,    // Front face
            4, 5, 6,      4, 6, 7,    // Back face
            8, 9, 10,     8, 10, 11,  // Top face
            12, 13, 14,   12, 14, 15, // Bottom face
            16, 17, 18,   16, 18, 19, // Right face
            20, 21, 22,   20, 22, 23  // Left face
        ];
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(VertexIndices), gl.STATIC_DRAW);
        VertexIndexBuffer.itemSize = 1;
        VertexIndexBuffer.numItems = 36;
		objectsToDraw[current_key++] = {
			position_buffer: VertexPositionBuffer,
			color_buffer: VertexColorBuffer,
			index_buffer: VertexIndexBuffer,
			color: color,
			center: center_coordinates
		};
	}
	
	function create_sphere(center_coordinates,color){
		var latitudeBands = 30;
        var longitudeBands = 30;
        var radius = 0.5*cellSize;
		
        var vertexPositionData = [];
        for (var latNumber=0; latNumber <= latitudeBands; latNumber++) {
            var theta = latNumber * Math.PI / latitudeBands;
            var sinTheta = Math.sin(theta);
            var cosTheta = Math.cos(theta);

            for (var longNumber=0; longNumber <= longitudeBands; longNumber++) {
                var phi = longNumber * 2 * Math.PI / longitudeBands;
                var sinPhi = Math.sin(phi);
                var cosPhi = Math.cos(phi);

                var x = cosPhi * sinTheta;
                var y = cosTheta;
                var z = sinPhi * sinTheta;
                var u = 1 - (longNumber / longitudeBands);
                var v = 1 - (latNumber / latitudeBands);
                vertexPositionData.push(radius * x);
                vertexPositionData.push(radius * y);
                vertexPositionData.push(radius * z);
            }
        }

        var indexData = [];
        for (var latNumber=0; latNumber < latitudeBands; latNumber++) {
            for (var longNumber=0; longNumber < longitudeBands; longNumber++) {
                var first = (latNumber * (longitudeBands + 1)) + longNumber;
                var second = first + longitudeBands + 1;
                indexData.push(first);
                indexData.push(second);
                indexData.push(first + 1);

                indexData.push(second);
                indexData.push(second + 1);
                indexData.push(first + 1);
            }
        }

		var VertexPositionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, VertexPositionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexPositionData), gl.STATIC_DRAW);
        VertexPositionBuffer.itemSize = 3;
        VertexPositionBuffer.numItems = vertexPositionData.length / 3;
		
        var VertexColorBuffer = gl.createBuffer()
		gl.bindBuffer(gl.ARRAY_BUFFER, VertexColorBuffer);
		var unpackedColors = [];
		var temp_color = color;
		for (var k = 0; k < vertexPositionData.length / 3; k++){
			/*for (var k = 0; k < 3; k++){
				//temp_color[k] += ((Math.random()-0.5)*.1);
				if (temp_color[k] > 1){
					temp_color[k] = 1;
				}
				if (temp_color[k] < 0){
					temp_color[k] = 0;
				}
			}*/
			temp_color[0] += ((Math.random()-0.5)*.02);
				if (temp_color[0] > 1){
					temp_color[0] = 1;
				}
				if (temp_color[0] < 0){
					temp_color[0] = 0;
				}
			temp_color[1] += ((Math.random()-0.5)*.02);
				if (temp_color[1] > 1){
					temp_color[1] = 1;
				}
				if (temp_color[1] < 0){
					temp_color[1] = 0;
				}
			temp_color[2] += ((Math.random()-0.5)*.02);
				if (temp_color[2] > 1){
					temp_color[2] = 1;
				}
				if (temp_color[2] < 0){
					temp_color[2] = 0;
				}
			unpackedColors = unpackedColors.concat(temp_color);
		}
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(unpackedColors), gl.STATIC_DRAW);
		VertexColorBuffer.itemSize = 4;
		VertexColorBuffer.numItems = vertexPositionData.length / 3;

        var VertexIndexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, VertexIndexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indexData), gl.STATIC_DRAW);
        VertexIndexBuffer.itemSize = 1;
        VertexIndexBuffer.numItems = indexData.length;
		objectsToDraw[current_key++] = {
			position_buffer: VertexPositionBuffer,
			color_buffer: VertexColorBuffer,
			index_buffer: VertexIndexBuffer,
			color: color,
			center: center_coordinates
		};
	}
	
	function create_xaxis(){
		var VertexPositionBuffer = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, VertexPositionBuffer);
		var strokeweight = gridweight*3;
		vertices = [
            // Front face
            0,  -strokeweight,  strokeweight,
             6,-strokeweight,  strokeweight,
            6,  strokeweight,  strokeweight,
			0,  strokeweight,  strokeweight,

            // Back face
           0,  -strokeweight,  -strokeweight,
             6.0, -strokeweight,  -strokeweight,
            6,  strokeweight,  -strokeweight,
			0,  strokeweight,  -strokeweight,

            // Top face
            0,  strokeweight,  strokeweight,
             0, strokeweight,  -strokeweight,
            6.0,  strokeweight,  -strokeweight,
            6.0,  strokeweight,  strokeweight,

            // Bottom face
            0,  -strokeweight,  strokeweight,
             0, -strokeweight,  -strokeweight,
            6.0,  -strokeweight,  -strokeweight,
            6.0,  -strokeweight,  strokeweight,

            // Right face
             6.0,  -strokeweight,  strokeweight,
             6.0, -strokeweight,  -strokeweight,
            6.0,  strokeweight,  -strokeweight,
            6.0,  strokeweight,  strokeweight,

            // Left face
            0,  -strokeweight,  strokeweight,
             0, -strokeweight,  -strokeweight,
            0,  strokeweight,  -strokeweight,
            0,  strokeweight,  strokeweight,
        ];
		for (var i = 0; i < vertices.length; i++){
			vertices[i] *= cellSize;
		}
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
        VertexPositionBuffer.itemSize = 3;
        VertexPositionBuffer.numItems = 24;
		var VertexColorBuffer = gl.createBuffer()
		gl.bindBuffer(gl.ARRAY_BUFFER, VertexColorBuffer);
		var unpackedColors = [];
		for (var k = 0; k < 24; k++){ //24 because the vertex buffer has 24 vertices, each must have a color
				unpackedColors = unpackedColors.concat(convert_color_code(1));
		}
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(unpackedColors), gl.STATIC_DRAW);
		VertexColorBuffer.itemSize = 4;
		VertexColorBuffer.numItems = 24;
		
        var VertexIndexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, VertexIndexBuffer);
        var VertexIndices = [
            0, 1, 2,      0, 2, 3,    // Front face
            4, 5, 6,      4, 6, 7,    // Back face
            8, 9, 10,     8, 10, 11,  // Top face
            12, 13, 14,   12, 14, 15, // Bottom face
            16, 17, 18,   16, 18, 19, // Right face
            20, 21, 22,   20, 22, 23  // Left face
        ];
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(VertexIndices), gl.STATIC_DRAW);
        VertexIndexBuffer.itemSize = 1;
        VertexIndexBuffer.numItems = 36;
		objectsToDraw[current_key++] = {
			position_buffer: VertexPositionBuffer,
			color_buffer: VertexColorBuffer,
			index_buffer: VertexIndexBuffer,
			color: convert_color_code(1),
			center: [0.0,0.0,0.0]
		};
	}
	
	function create_zaxis(){
		var VertexPositionBuffer = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, VertexPositionBuffer);
		var strokeweight = gridweight*3;
		vertices = [
            // Front face
            -strokeweight,  strokeweight,  6.0,
             strokeweight, strokeweight,  6.0,
            strokeweight,  -strokeweight,  6.0,
			-strokeweight,  -strokeweight,  6.0,

            // Back face
           -strokeweight,  strokeweight,  0,
             strokeweight, strokeweight,  0,
            strokeweight,  -strokeweight,  0,
			-strokeweight,  -strokeweight,  0,

            // Top face
            -strokeweight,  strokeweight,  6.0,
             -strokeweight, strokeweight,  0,
            strokeweight,  strokeweight,  0,
            strokeweight,  strokeweight,  6.0,

            // Bottom face
            -strokeweight,  -strokeweight,  6.0,
             -strokeweight, -strokeweight,  0,
            strokeweight,  -strokeweight,  0,
            strokeweight,  -strokeweight,  6.0,

            // Right face
             strokeweight,  -strokeweight,  6.0,
             strokeweight, -strokeweight,  0,
            strokeweight,  strokeweight,  0,
            strokeweight,  strokeweight,  6.0,

            // Left face
            -strokeweight,  -strokeweight,  6.0,
             -strokeweight, -strokeweight,  0,
            -strokeweight,  strokeweight,  0,
            -strokeweight,  strokeweight,  6.0,
        ];
		for (var i = 0; i < vertices.length; i++){
			vertices[i] *= cellSize;
		}
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
        VertexPositionBuffer.itemSize = 3;
        VertexPositionBuffer.numItems = 24;
		var VertexColorBuffer = gl.createBuffer()
		gl.bindBuffer(gl.ARRAY_BUFFER, VertexColorBuffer);
		var unpackedColors = [];
		for (var k = 0; k < 24; k++){ //24 because the vertex buffer has 24 vertices, each must have a color
				unpackedColors = unpackedColors.concat(convert_color_code(0));
		}
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(unpackedColors), gl.STATIC_DRAW);
		VertexColorBuffer.itemSize = 4;
		VertexColorBuffer.numItems = 24;
		
        var VertexIndexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, VertexIndexBuffer);
        var VertexIndices = [
            0, 1, 2,      0, 2, 3,    // Front face
            4, 5, 6,      4, 6, 7,    // Back face
            8, 9, 10,     8, 10, 11,  // Top face
            12, 13, 14,   12, 14, 15, // Bottom face
            16, 17, 18,   16, 18, 19, // Right face
            20, 21, 22,   20, 22, 23  // Left face
        ];
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(VertexIndices), gl.STATIC_DRAW);
        VertexIndexBuffer.itemSize = 1;
        VertexIndexBuffer.numItems = 36;
		objectsToDraw[current_key++] = {
			position_buffer: VertexPositionBuffer,
			color_buffer: VertexColorBuffer,
			index_buffer: VertexIndexBuffer,
			color: convert_color_code(0),
			center: [0.0,0.0,0.0]
		};
	}
	
	function create_yaxis(){
		var VertexPositionBuffer = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, VertexPositionBuffer);
		var strokeweight = gridweight*3;
		vertices = [
            // Front face
            -strokeweight,  0,  strokeweight,
             strokeweight,0,  strokeweight,
            strokeweight,  10.0,  strokeweight,
			-strokeweight,  10.0,  strokeweight,

            // Back face
           -strokeweight,  0,  -strokeweight,
             strokeweight,0,  -strokeweight,
            strokeweight,  10.0,  -strokeweight,
			-strokeweight,  10.0,  -strokeweight,

            // Top face
            -strokeweight,  10.0,  strokeweight,
             -strokeweight, 10.0,  -strokeweight,
            strokeweight,  10.0,  -strokeweight,
            strokeweight,  10.0,  strokeweight,

            // Bottom face
            -strokeweight,  0,  strokeweight,
             -strokeweight, 0,  -strokeweight,
            strokeweight,  0,  -strokeweight,
            strokeweight,  0,  strokeweight,

            // Right face
             strokeweight,  0,  strokeweight,
             strokeweight, 0,  -strokeweight,
            strokeweight,  10.0,  -strokeweight,
            strokeweight,  10.0,  strokeweight,

            // Left face
            -strokeweight,  0,  strokeweight,
             -strokeweight, 0,  -strokeweight,
            -strokeweight,  10.0,  -strokeweight,
            -strokeweight,  10.0,  strokeweight,
        ];
		for (var i = 0; i < vertices.length; i++){
			vertices[i] *= cellSize;
		}
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
        VertexPositionBuffer.itemSize = 3;
        VertexPositionBuffer.numItems = 24;
		var VertexColorBuffer = gl.createBuffer()
		gl.bindBuffer(gl.ARRAY_BUFFER, VertexColorBuffer);
		var unpackedColors = [];
		for (var k = 0; k < 24; k++){ //24 because the vertex buffer has 24 vertices, each must have a color
				unpackedColors = unpackedColors.concat(convert_color_code(2));
		}
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(unpackedColors), gl.STATIC_DRAW);
		VertexColorBuffer.itemSize = 4;
		VertexColorBuffer.numItems = 24;
		
        var VertexIndexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, VertexIndexBuffer);
        var VertexIndices = [
            0, 1, 2,      0, 2, 3,    // Front face
            4, 5, 6,      4, 6, 7,    // Back face
            8, 9, 10,     8, 10, 11,  // Top face
            12, 13, 14,   12, 14, 15, // Bottom face
            16, 17, 18,   16, 18, 19, // Right face
            20, 21, 22,   20, 22, 23  // Left face
        ];
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(VertexIndices), gl.STATIC_DRAW);
        VertexIndexBuffer.itemSize = 1;
        VertexIndexBuffer.numItems = 36;
		objectsToDraw[current_key++] = {
			position_buffer: VertexPositionBuffer,
			color_buffer: VertexColorBuffer,
			index_buffer: VertexIndexBuffer,
			color: convert_color_code(2),
			center: [0.0,0.0,0.0]
		};
	}
	
	
	
</script>

<body onload="webGLStart();">
    <canvas id="lesson04-canvas" style="border: none;" width="800" height="700"></canvas><br>
	<p style="float: right; width: 600px; position: fixed;top:0px; left: 850px"><big><strong><font size = '9px' face="calibri">Welcome to 3D Dr. Mario, by Abiyaz Chowdhury. Spring 2017, ECE462. </font></strong></big></p>
	<p style="float: right; width: 600px; position: fixed;top:180px; left: 850px"><font size = '6px' face="calibri">Use the left/right and up/down arrow keys to move the current pill along the cyan and magenta axes respectively. Use the a/z, s/x, and d/c  keys to rotate the cube 90 or -90 degrees along the cyan, magenta and yellow axes respectively. Kill all the viruses (spheres) to win.</font></p>
	<div style = "float: right; width: 600px; position: fixed;top:480px;left: 850px">
		<audio controls>
			<source src="./final_files/Fever2.mp3" type="audio/ogg">
		</audio>
	</div>
	<p style="float: right; width: 600px; position: fixed;top:500px; left: 850px"><big><strong><font  id="gamestatus" size = '9px' face="calibri"> Game in progress </p>
</body>

